<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
            color: #333;
        }
        header {
            background: linear-gradient(90deg, #4caf50, #81c784);
            color: white;
            text-align: center;
            padding: 2rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        header h1 {
            margin: 0;
            animation: fadeIn 1.5s ease-in-out;
        }
        section {
            padding: 2rem;
            margin: 1rem auto;
            max-width: 800px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: slideIn 1s ease-in-out;
        }
        section h2 {
            text-align: center;
            color: #4caf50;
        }
        section ul {
            padding-left: 1.5rem;
        }
        footer {
            text-align: center;
            padding: 1rem;
            background: #4caf50;
            color: white;
            margin-top: 2rem;
        }
        .highlight {
            color: #4caf50;
            font-weight: 600;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .hover-effect:hover {
            transform: scale(1.05);
            transition: transform 0.3s;
        }
        nav {
            background: #4caf50;
            padding: 1rem;
            text-align: center;
        }
        nav a {
            margin: 0 1rem;
            color: white;
            text-decoration: none;
            font-weight: 600;
        }
        nav a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <header>
        <h1>Course Reflections</h1>
    </header>


    <section id="nature" class="hover-effect">
        <h2>1. What are the kinds of problems we see in nature? (iteration, recursion, backtracking)?</h2>
        <p><span class="highlight">Example:</span> Nature provides numerous examples that parallel the concepts of iteration, recursion, and backtracking in computational terms. The recurring cycle of seasons, which progresses and repeats predictably each year, is a clear representation of iteration. Similarly, the growth pattern of cabbage leaves, where each layer forms upon the previous one in a structured sequence, embodies recursion—a process building upon itself. Ants foraging for food illustrate backtracking; they traverse paths in search of resources and, upon encountering obstacles or dead ends, retrace their steps to explore alternative routes. These examples showcase how fundamental algorithmic principles are intricately mirrored in natural processes, emphasizing the profound connection between computational logic and the patterns observed in the natural world.</p>
        <h2>2. What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth?</h2>
        <p><span class="highlight">Example:</span> **Space Complexity** refers to the additional memory an algorithm requires during execution, while **Time Complexity** indicates the duration it takes for an algorithm to complete its task. These measures are crucial for assessing an algorithm's efficiency, enabling programmers to determine its suitability for specific applications. 

The **order of growth** describes how an algorithm’s resource requirements scale with the size of the input:

- **O(1)**: Constant growth, independent of input size.  
- **O(n)**: Linear growth, directly proportional to the input size.  
- **O(log n)**: Logarithmic growth, increasing slowly as the input size grows.</p>
        <h2>Take away from different design principles from chapter 2?</h2>
        <p><span class="highlight">Example:</span> Studying different algorithms has helped me grasp their key principles and applications more clearly. For example, AVL trees and Red-Black trees taught me how maintaining balance in data structures is essential for efficient operations. Exploring graph traversal methods like DFS and BFS showed how different strategies can solve problems effectively—DFS being more exploratory and BFS taking a systematic approach. Learning sorting algorithms like Merge Sort, which divides and merges data, and Quick Sort, which strategically swaps elements, gave me a better understanding of how they work in practice. These concepts have provided me with a solid foundation in understanding algorithms and their practical uses.</p>
        <h2>The hierarchical data and how different tree data structures solve and optimize over problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)</h2>
    </section>
    <section id="sdg-goal">
            <h2>SDG Goal 11: Smart City Solutions</h2>
            <ul>
                <li><strong>Goal:</strong> Make cities and human settlements inclusive, safe, resilient, and sustainable.</li>
                <li><strong>Target:</strong> Provide access to safe, affordable, accessible, and sustainable transport systems for all by 2030.</li>
                <li><strong>Indicator:</strong> Proportion of population with convenient access to public transport, by sex, age, and persons with disabilities.</li>
            </ul>
        </section>

        <section id="smart-city-solutions">
            <h2>Smart City Solutions: Identified Business Cases</h2>
            <h3>1. Smart Parking Systems</h3>
            <p><strong>Problem:</strong> Traffic congestion due to inefficient parking space management and lack of real-time availability information.</p>
            <p><strong>Solution:</strong> Smart parking systems utilizing tries and dynamic queues to optimize parking availability and direct vehicles to open spots in real-time.</p>

            <h4>Algorithmic Applications:</h4>
            <h5>Parking Slot Availability using Trie</h5>
            <p><strong>Functionality:</strong> A trie efficiently stores and retrieves parking slots based on location and type (e.g., compact, regular, or handicapped).</p>
            <p><strong>Example Usage:</strong></p>
            <ul>
                <li>Each node in the trie represents a level of detail (e.g., city > parking lot > slot number).</li>
                <li>Quick lookup for the nearest available parking slot in a specific area.</li>
            </ul>
            <p>View the full <a href="https://github.com/Chinmayi-K-B/Code.github.io/blob/main/Smart_parking_trie_code.cpp" target="_blank">Smart Parking Trie Code</a> on GitHub</p>

            <h5>Dynamic Queue for Real-time Slot Allocation</h5>
            <p><strong>Functionality:</strong> A queue dynamically manages the order of vehicles waiting for parking slots.</p>
            <p><strong>Example Usage:</strong></p>
            <ul>
                <li>Vehicles are queued as they approach the parking area.</li>
                <li>As slots become available, the queue ensures that the nearest or most eligible vehicle is allocated a spot based on priority (e.g., arrival time or special needs).</li>
            </ul>
            <p>View the full <a href="https://github.com/Chinmayi-K-B/Code.github.io/blob/main/Smart_parking_trie_code.cpp" target="_blank">Parking Queue Code</a> on GitHub</p>

            <h3>2. EV Charging Station Management</h3>
            <p><strong>Problem:</strong> Efficient management of EV charging stations to support the growing adoption of electric vehicles.</p>
            <p><strong>Solution:</strong> Smart management using tries and dynamic queues for real-time allocation and efficient utilization of charging slots.</p>

            <h4>Algorithmic Applications:</h4>
            <h5>EV Charging Slot Availability using Trie</h5>
            <p><strong>Functionality:</strong> A trie efficiently stores and retrieves EV charging slots based on location, type, and availability.</p>
            <p><strong>Example Usage:</strong></p>
            <ul>
                <li>Each node in the trie represents a level of detail (e.g., city > charging station > slot number).</li>
                <li>Quick lookup for the nearest available charging station or slot.</li>
            </ul>
            <p>View the full <a href="https://github.com/Chinmayi-K-B/Code.github.io/blob/main/Ev_charging_trie_code.cpp" target="_blank">EV Charging Trie Code</a> on GitHub</p>

            <h5>Dynamic Queue for Real-time EV Slot Allocation</h5>
            <p><strong>Functionality:</strong> A queue manages the order of vehicles waiting for EV charging slots.</p>
            <p><strong>Example Usage:</strong></p>
            <ul>
                <li>Vehicles are queued as they arrive at a charging station.</li>
                <li>As slots become available, the vehicle at the front of the queue is allocated a charging slot.</li>
            </ul>
            <p>View the full <a href="https://github.com/yourusername/ev-charging-queue" target="_blank">EV Charging Queue Code</a> on GitHub</p>
        </section>

        <footer>
            <p>&copy; 2024 Algorithms, Nature, and SDG Goal 11: Smart City Solutions</p>
        </footer>
    </main>
</body>
</html>
